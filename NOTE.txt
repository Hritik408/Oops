1. All classes have at least one constructor. If a class does not explicitly declare any, the Java compiler automatically provides a no-argument 
constructor, also called the default constructor. This default constructor calls the class parent’s no-argument constructor (as it contains only one 
statement i.e super();), or the Object class constructor if the class has no other parent (as the Object class is the parent of all classes either 
directly or indirectly). 



2. Creating multiple objects by one type only (A good practice) 
In real-time, we need different objects of a class in different methods. Creating a number of references for storing them is not a good practice and 
therefore we declare a static reference variable and use it whenever required. In this case, the wastage of memory is less. The objects that are not 
referenced anymore will be destroyed by the Garbage Collector of Java. 

Example:

Test test = new Test();
test = new Test();
In the inheritance system, we use a parent class reference variable to store a sub-class object. In this case, we can switch into different subclass 
objects using the same referenced variable. 

Example:

class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}
public class Test
{
    // using Dog object
    Animal obj = new Dog();
    // using Cat object
    obj = new Cat();
}


3. Advantages of Method Overloading 
Method overloading improves the Readability and reusability of the program.
Method overloading reduces the complexity of the program.
Using method overloading, programmers can perform a task efficiently and effectively.
Using method overloading, it is possible to access methods performing related functions with slightly different arguments and types.
Objects of a class can also be initialized in different ways using the constructors.

https://www.geeksforgeeks.org/method-overloading-in-java/  continue


4. // Demo Class 
class Demo { 
	public void show(int x) 
	{ 
		System.out.println("In int" + x); 
	} 
	public void show(String s) 
	{ 
		System.out.println("In String" + s); 
	} 
	public void show(byte b) 
	{ 
		System.out.println("In byte" + b); 
	} 
} 

class UseDemo { 
	public static void main(String[] args) 
	{ 
		byte a = 25; 
		Demo obj = new Demo(); 

		// it will go to 
		// byte argument 
		obj.show(a); 

		// String 
		obj.show("hello"); 

		// Int 
		obj.show(250); 

		// Since char is 
		// not available, so the datatype 
		// higher than char in terms of 
		// range is int. 
		obj.show('A'); 

		// String 
		obj.show("A"); 

		// since float datatype 
		// is not available and so it's higher 
		// datatype, so at this step their 
		// will be an error. 
		obj.show(7.5); 
	} 
}



4. Keyword	Usage
abstract	Specifies that a class or method will be implemented later, in a subclass 
assert	Assert describes a predicate placed in a Java program to indicate that the developer thinks that the predicate is always true at that place.
boolean	A data type that can hold True and False values only 
break	A control statement for breaking out of loops.
byte	A data type that can hold 8-bit data values 
case	Used in switch statements to mark blocks of text
catch	Catches exceptions generated by try statements
char	A data type that can hold unsigned 16-bit Unicode characters
class	Declares a new class
continue	Sends control back outside a loop 
default	Specifies the default block of code in a switch statement
do	Starts a do-while loop
double	A data type that can hold 64-bit floating-point numbers
else	Indicates alternative branches in an if statement 
enum	A Java keyword is used to declare an enumerated type. Enumerations extend the base class.
extends	Indicates that a class is derived from another class or interface 
final	Indicates that a variable holds a constant value or that a method will not be overridden
finally	Indicates a block of code in a try-catch structure that will always be executed
float	A data type that holds a 32-bit floating-point number 
for	Used to start a for loop
if	Tests a true/false expression and branches accordingly
implements	Specifies that a class implements an interface 
import	References other classes
instanceof	Indicates whether an object is an instance of a specific class or implements an interface 
int	A data type that can hold a 32-bit signed integer 
interface	Declares an interface
long	A data type that holds a 64-bit integer
native	Specifies that a method is implemented with native (platform-specific) code 
new	Creates new objects 
null	This indicates that a reference does not refer to anything 
package	Declares a Java package
private	An access specifier indicating that a method or variable may be accessed only in the class it’s declared in
protected	An access specifier indicating that a method or variable may only be accessed in the class it’s declared in (or a subclass of the class it’s declared in or other classes in the same package)
public	An access specifier used for classes, interfaces, methods, and variables indicating that an item is accessible throughout the application (or where the class that defines it is accessible)
return	Sends control and possibly a return value back from a called method 
short	A data type that can hold a 16-bit integer 
static	Indicates that a variable or method is a class method (rather than being limited to one particular object)
strictfp	A Java keyword is used to restrict the precision and rounding of floating-point calculations to ensure portability.
super	Refers to a class’s base class (used in a method or class constructor) 
switch	A statement that executes code based on a test value 
synchronized	Specifies critical sections or methods in multithreaded code
this	Refers to the current object in a method or constructor 
throw	Creates an exception 
throws	Indicates what exceptions may be thrown by a method 
transient	Specifies that a variable is not part of an object’s persistent state
try	Starts a block of code that will be tested for exceptions 
void	Specifies that a method does not have a return value
volatile	This indicates that a variable may change asynchronously
while	Starts a while loop
sealed

The sealed keyword is used to declare a class as “sealed,” meaning it restricts which classes can extend it.

permits

The permits keyword is used within a sealed class declaration to specify the subclasses that are permitted to extend it.


5.

ChatGPT
In Java, the superclass of all classes is java.lang.Object. Every class in Java implicitly extends Object if no other superclass is specified. This means that all classes inherit methods from Object, such as toString(), equals(), hashCode(), and others. Here’s an overview of Object as the root class in Java’s class hierarchy:

Key Methods of java.lang.Object
toString(): Returns a string representation of the object.

java
Copy code
@Override
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
equals(Object obj): Indicates whether some other object is "equal to" this one.

java
Copy code
@Override
public boolean equals(Object obj) {
    return this == obj;
}
hashCode(): Returns a hash code value for the object.

java
Copy code
@Override
public int hashCode() {
    return System.identityHashCode(this);
}
getClass(): Returns the runtime class of this Object.

java
Copy code
public final Class<?> getClass() {
    return Class.forName(this.getName());
}
clone(): Creates and returns a copy of this object.

java
Copy code
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
finalize(): Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

java
Copy code
protected void finalize() throws Throwable {
    // Clean up resources
}
Example
Here’s a simple example to demonstrate that every class in Java inherits from Object:

java
Copy code
class MyClass {
    // This class implicitly extends java.lang.Object
}

public class Main {
    public static void main(String[] args) {
        MyClass myObject = new MyClass();
        
        // Since MyClass extends Object, we can use Object's methods
        System.out.println(myObject.toString());       // Calls Object's toString() method
        System.out.println(myObject.hashCode());      // Calls Object's hashCode() method
        System.out.println(myObject.equals(myObject)); // Calls Object's equals() method
    }
}
Explanation
MyClass implicitly extends java.lang.Object.
Methods like toString(), hashCode(), and equals() can be called on an instance of MyClass because they are inherited from Object.
By having Object as the root class, Java provides a common protocol for all objects, which ensures consistency and interoperability in the language. This design is foundational to the Java language, enabling polymorphism and a consistent type hierarchy.